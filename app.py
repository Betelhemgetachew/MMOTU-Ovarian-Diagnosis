import streamlit as st
import torch
import torch.nn as nn
import torchvision.models as models
import segmentation_models_pytorch as smp
import albumentations as A
from albumentations.pytorch import ToTensorV2
import numpy as np
import cv2
from PIL import Image
import os
from fpdf import FPDF
import gdown

# =========================
# Page Configuration
# =========================
st.set_page_config(
    page_title="MMOTU AI Diagnostics",
    page_icon="ü©∫",
    layout="wide",
    initial_sidebar_state="expanded"
)

# =========================
# Custom Styling
# =========================
st.markdown("""
    <style>
    .main { background-color: #0e1117; }
    h1 { color: #4da6ff; text-align: center; }
    .stAlert { background-color: #262730; color: #fafafa; border: 1px solid #4da6ff; }
    div.stButton > button { background-color: #4da6ff; color: white; border-radius: 8px; width: 100%; }
    .diagnosis-text { font-weight: bold; font-size: 24px; padding: 10px; border-radius: 5px; }
    </style>
""", unsafe_allow_html=True)

# -------- Device --------
DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# =========================
# 1. Configuration & Paths
# =========================
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
MODEL_DIR = os.path.join(BASE_DIR, "models")

# Ensure models folder exists
os.makedirs(MODEL_DIR, exist_ok=True)

SEG_MODEL_PATH = os.path.join(MODEL_DIR, "mmotu_segmentation_best_model.pth")
CLS_MODEL_PATH = os.path.join(MODEL_DIR, "mmotu_classifier_fullimage_best.pth")

# --- GOOGLE DRIVE FILE IDs ---
SEG_FILE_ID = '1JL8mDDxJ81dhF9s3sSV2JOxlZglsSCaF' 
CLS_FILE_ID = '1kLNPFI1nKd3cN-P57HX7tgOv3kZnb7Sy'
# -----------------------------

CLASS_NAMES = [
    "Normal Ovary", "Simple Cyst", "Chocolate Cyst", 
    "Serous Cystadenoma", "Mucinous Cystadenoma", 
    "Teratoma", "Theca Cell Tumor", "High-Grade Serous Carcinoma"
]
NUM_CLASSES = len(CLASS_NAMES)

# --- Medical Dictionary ---
MEDICAL_INFO = {
    "Normal Ovary": "Healthy ovarian tissue with no visible abnormalities.",
    "Simple Cyst": "A fluid-filled sac. Most are benign and often resolve on their own.",
    "Chocolate Cyst": "Endometrioma. A cyst filled with old blood, often linked to endometriosis.",
    "Serous Cystadenoma": "A benign tumor filled with thin, watery fluid.",
    "Mucinous Cystadenoma": "A benign tumor filled with a gelatinous, mucous-type fluid.",
    "Teratoma": "A germ cell tumor that may contain hair, teeth, or bone tissue.",
    "Theca Cell Tumor": "A rare, usually benign solid tumor of the ovary.",
    "High-Grade Serous Carcinoma": "A type of ovarian cancer that requires immediate clinical attention."
}

# =========================
# 2. PDF Generation Function
# =========================
def create_pdf(diagnosis, confidence, image_path, notes=""):
    pdf = FPDF()
    pdf.add_page()
    
    # Title
    pdf.set_font("Arial", 'B', 20)
    pdf.cell(190, 15, txt="MMOTU AI Diagnostic Report", ln=1, align='C')
    pdf.set_font("Arial", size=10)
    pdf.cell(190, 10, txt="Automated Ultrasound Analysis", ln=1, align='C')
    pdf.line(10, 35, 200, 35)
    
    # Image
    pdf.ln(10)
    pdf.image(image_path, x=55, y=45, w=100)
    
    # Results
    pdf.ln(110)
    pdf.set_font("Arial", 'B', 14)
    pdf.cell(190, 10, txt="Analysis Results:", ln=1, align='L')
    
    pdf.set_font("Arial", size=12)
    pdf.cell(50, 10, txt="Primary Diagnosis:", align='L')
    pdf.set_font("Arial", 'B', 12)
    pdf.cell(140, 10, txt=f"{diagnosis}", ln=1, align='L')
    
    # Add Definition
    definition = MEDICAL_INFO.get(diagnosis, "")
    if definition:
        pdf.set_font("Arial", 'I', 10)
        pdf.multi_cell(190, 6, txt=f"({definition})")
        pdf.ln(2)

    pdf.set_font("Arial", size=12)
    pdf.cell(50, 10, txt="AI Confidence:", align='L')
    pdf.cell(140, 10, txt=f"{confidence:.2f}%", ln=1, align='L')
    
    if notes:
        pdf.ln(5)
        pdf.set_font("Arial", 'B', 12)
        pdf.cell(190, 10, txt="Physician Notes:", ln=1, align='L')
        pdf.set_font("Arial", size=12)
        pdf.multi_cell(190, 10, txt=notes)
    
    pdf.ln(20)
    pdf.set_font("Arial", 'I', 8)
    pdf.multi_cell(190, 5, txt="DISCLAIMER: This report is generated by an AI system (MMOTU Project). It is intended for research and educational purposes only.")
    
    return pdf.output(dest="S").encode("latin-1")

# =========================
# 3. Load Models (Spinner / Invisible Download)
# =========================
@st.cache_resource
def load_models():
    # Only show spinner if models are missing
    if not os.path.exists(SEG_MODEL_PATH) or not os.path.exists(CLS_MODEL_PATH):
        with st.spinner("Setting up AI models... (This happens once)"):
            if not os.path.exists(SEG_MODEL_PATH):
                url = f'https://drive.google.com/uc?id={SEG_FILE_ID}'
                gdown.download(url, SEG_MODEL_PATH, quiet=False)

            if not os.path.exists(CLS_MODEL_PATH):
                url = f'https://drive.google.com/uc?id={CLS_FILE_ID}'
                gdown.download(url, CLS_MODEL_PATH, quiet=False)

    seg_model = smp.Unet(encoder_name="resnet34", encoder_weights=None, in_channels=3, classes=1, activation="sigmoid")
    cls_model = models.resnet18(weights=None)
    cls_model.fc = nn.Linear(cls_model.fc.in_features, NUM_CLASSES)

    try:
        if os.path.exists(SEG_MODEL_PATH):
            seg_model.load_state_dict(torch.load(SEG_MODEL_PATH, map_location=DEVICE))
        else:
            st.error(f"‚ùå Segmentation model failed to download.")
            return None, None

        if os.path.exists(CLS_MODEL_PATH):
            cls_model.load_state_dict(torch.load(CLS_MODEL_PATH, map_location=DEVICE))
        else:
            st.error(f"‚ùå Classifier model failed to download.")
            return None, None
            
    except Exception as e:
        st.error(f"Error loading models: {e}")
        return None, None

    seg_model.to(DEVICE).eval()
    cls_model.to(DEVICE).eval()
    return seg_model, cls_model

seg_model, cls_model = load_models()

transform_base = A.Compose([
    A.Resize(256, 256),
    A.Normalize(mean=(0.485,0.456,0.406), std=(0.229,0.224,0.225)),
    ToTensorV2()
])

# =========================
# 4. Processing Functions
# =========================
def process_segmentation(pil_image, threshold=0.5):
    img = np.array(pil_image.convert("RGB"))
    original_size = img.shape[:2]

    augmented = transform_base(image=img)
    input_tensor = augmented['image'].unsqueeze(0).to(DEVICE)

    with torch.no_grad():
        pred_mask = seg_model(input_tensor)[0,0].cpu().numpy()

    mask_bin = (pred_mask > threshold).astype(np.uint8)
    mask_resized = cv2.resize(mask_bin, (original_size[1], original_size[0]), interpolation=cv2.INTER_NEAREST)

    color_mask = np.zeros_like(img)
    color_mask[:, :, 0] = 255 
    color_mask = cv2.bitwise_and(color_mask, color_mask, mask=mask_resized)
    overlay = cv2.addWeighted(img, 1.0, color_mask, 0.4, 0)

    return mask_resized, overlay

def crop_tumor_region(pil_image, mask_bin):
    img_arr = np.array(pil_image.convert("RGB"))
    contours, _ = cv2.findContours(mask_bin, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    if not contours:
        return None 

    c = max(contours, key=cv2.contourArea)
    x, y, w, h = cv2.boundingRect(c)
    pad = 20
    h_img, w_img = img_arr.shape[:2]
    y1, y2 = max(0, y - pad), min(h_img, y + h + pad)
    x1, x2 = max(0, x - pad), min(w_img, x + w + pad)

    cropped_img = img_arr[y1:y2, x1:x2]
    return Image.fromarray(cropped_img)

def predict_class(pil_image):
    img = np.array(pil_image.convert("RGB"))
    augmented = transform_base(image=img)
    input_tensor = augmented['image'].unsqueeze(0).to(DEVICE)
    with torch.no_grad():
        output = cls_model(input_tensor)
        probs = torch.nn.functional.softmax(output, dim=1).cpu().numpy()[0]
    return probs

# =========================
# 5. UI Layout
# =========================
st.title("ü©∫ MMOTU: Intelligent Ovarian Tumor Diagnosis")
st.markdown("**Powered by U-Net Segmentation & ResNet Classification**")
st.warning("‚ö†Ô∏è **Disclaimer:** This tool is for educational/research purposes only. Not for clinical diagnosis.")

# Sidebar
st.sidebar.header("Configuration")
seg_threshold = st.sidebar.slider("Sensitivity (Threshold)", 0.1, 0.9, 0.5, 0.05)
st.sidebar.info("Adjust threshold if the red mask is too small or too messy.")

# Main Logic
uploaded_file = st.file_uploader("üìÇ Upload Ultrasound Image", type=["jpg", "png", "jpeg"])

if uploaded_file and seg_model and cls_model:
    image = Image.open(uploaded_file)
    
    st.markdown("### 1. Image Analysis")
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.image(image, caption="Original Ultrasound", use_container_width=True)

    with st.spinner("Analyzing tissue structure..."):
        # Task 1
        mask, overlay = process_segmentation(image, threshold=seg_threshold)
        
        with col2:
            st.image(overlay, caption="AI Segmentation (Transparent Overlay)", use_container_width=True)

        # Task 2
        tumor_found = np.sum(mask) > 0
        if tumor_found:
            cropped_view = crop_tumor_region(image, mask)
            if cropped_view:
                with col3:
                    st.image(cropped_view, caption="Zoomed Region of Interest", width=250)
        else:
             with col3:
                st.info("No distinct tumor region found for zooming.")

        # Task 3
        probs = predict_class(image) 
        top_idx = np.argmax(probs)
        confidence = probs[top_idx]
        diagnosis = CLASS_NAMES[top_idx]

        # --- Report Section ---
        st.markdown("---")
        st.markdown("### 2. Diagnosis Report")
        
        is_uncertain = confidence < 0.60
        
        c1, c2 = st.columns([1, 1.5])
        
        with c1:
            st.markdown(f"**Primary Diagnosis:**")
            
            if is_uncertain:
                st.warning(f"‚ö†Ô∏è **Inconclusive**\n\nThe AI detected '{diagnosis}' but confidence is low ({confidence*100:.1f}%). Clinical review required.")
                final_status = f"Uncertain ({diagnosis}?)"
            else:
                is_malignant = "Carcinoma" in diagnosis or "Teratoma" in diagnosis
                color = "red" if is_malignant else "#28a745"
                st.markdown(f"<h2 style='color: {color};'>{diagnosis}</h2>", unsafe_allow_html=True)
                st.metric("Confidence Score", f"{confidence*100:.2f}%")
                
                definition = MEDICAL_INFO.get(diagnosis, "No detailed definition available.")
                st.info(f"‚ÑπÔ∏è **What is this?**\n\n{definition}")

                final_status = diagnosis

            if tumor_found:
                st.caption("‚úÖ Tumor location verified by Segmentation Model.")
            else:
                st.caption("‚ö†Ô∏è Segmentation Model did not highlight a region.")

            # PDF Download
            st.markdown("---")
            st.markdown("#### üìÑ Export Report")
            notes = st.text_area("Physician Notes (Optional)", height=70)
            
            if st.button("Generate PDF Report"):
                temp_img_path = "temp_scan_report.png"
                image.save(temp_img_path)
                
                pdf_bytes = create_pdf(final_status, confidence*100, temp_img_path, notes)
                
                st.download_button(
                    label="‚¨áÔ∏è Click to Download PDF",
                    data=pdf_bytes,
                    file_name="MMOTU_Patient_Report.pdf",
                    mime="application/pdf"
                )
                
                if os.path.exists(temp_img_path):
                    os.remove(temp_img_path)

        with c2:
            st.markdown("**Probability Distribution:**")
            chart_data = {name: float(p) for name, p in zip(CLASS_NAMES, probs)}
            st.bar_chart(chart_data)

# Footer
st.markdown("---")
st.markdown("<div style='text-align: center; color: gray;'>Developed by Betelhem Getachew | MMOTU Research Project 2025</div>", unsafe_allow_html=True)
